# Optional Extras

- TEST
  - Play test.
  - Examine more thoroughly in different browsers, including Edge and Opera, which I haven't looked at yet.
- FIX
  - Possibly fixed now that I dealt with another disconnection-related error, but, just in case, here's a note of what happened: I once saw a bug where server and client logged that one of two players had disconnected, but they hadn't. Both players were still in the chat. Only one had the ready button visible. On pressing it, the countdown was triggered for both. Haven't manage to replicate it.
  - A bug I saw once, but haven't managed to replicate after many attempts, possibly already fixed now that disconnections during countdown are handled better. But I'll leave the details here just in case. Server crashed when a player in Safari pressed CTR+SHIFT+R to view simplified page, without styles, during countdown. Apparently this led to them being undefined even though the normal disconnection logic had not gone ahead. It triggered that classic lightning-conductor-of-errors, `isDead(player)`: `return grid[player?.position?.y][player?.position?.x].type === "fire";` (accusing arrow points to 2nd instance of player in the line), "TypeError: Cannot read properties of undefined (reading 'undefined')". Since then I've added some protections and logging in case of future issues.
- NETWORK
  - Consider what to do at bottlenecks where a lagging client might prevent progress indefinitely: at the end of the countdown and on game over, waiting for everyone to press the bomb (ready) button. In a multi-instance version, this would be taken care of by the regular connection logic.
  - Implement some decent reconnection logic (e.g. 3 attempts then consider gone: update player.id to new id using index from client to link them; better yet, use a cookie. Test how well connections last, using a mobile hotspot.)
  - Attempt clientside prediction with rollback. At the moment, each player's direction is set for themselves immediately on keydown. This at least gives some impression of immediate responsivity without affecting other players if the change in direction isn't processed. To allow each player to see themselves move immediately, we'd have to deal with the fact that currently a short keypress is doesn't necessarily lead to movement on the server at the next tick. If the keyup signal arrives first, the movement will never be executed on the server. If a flag is used to make sure the move is always allowed, it seems to result in double moves, which I think make for a worse player experience than occasional failure to move.
- COUNTDOWN
  - Move control to server? Currently each client performs the countdown. The server waits for all connected players to signal that they've finished. Consider whether to limit the waiting time in case one player's signal is delayed. I suppose that might relate to more general logic for under what circumstances to disconnect a lagging player at bottlenecks--see NETWORK above.
  - Throttle ready/pause button.
- OPTIMIZE
  - Use CSS classes instead of `setSprite(spriteX, spriteY, playerWrapper)` for the walking animation: two speeds according to whether the player takes `normalTime` or `skateTime` to move from one cell to the next, keyframes specifying background position for each of the three frames of the walk, speed change on collecting skate powerup in `getPowerup(y, x, powerup, index)` and on "spawned" if `!hasSkate` (having dropped it when killed). See also `animateWalk(index)` and `gameLoop(timestamp`.
  - If arrays will have a known size, initialize them with that size.
  - Recycle arrays and objects where possible, rather than pushing, popping, and making new ones.
  - `socket.IO` was probably overkill on this project, but we might as well leave it for now. Their rooms feature could make it more convenient to implement multiple game instances, especially if we went the single-threaded route, albeit we have implemented our own rooms on other projects. Look at pros and cons before changing.
- BONUS
  - Easy bonus: allow a 5th player to be spawed in the center of the grid. (Make sure they have space and that they don't interfere with the mechanism to always place one each of the three basic powerups.)
  - POWERUPS
    - `bomb-throw` powerup, aka `bomb-push`.
    - Not on the list: `smoke-bomb` that fills nearby tunnels with smoke that disperses more slowly than fire, and can be walked through but not seen through.
    - Not on the list: `soft-block-push`: push a soft block if there's nothing behind it.
  - CO-OP MODES
    - Teams.
    - AI opponent. (If we implement an AI opponent, we can also use it to fill in empty slots in the regular battle royale mode.)
  - SINGLE-PLAYER MODE
    - The enemies from the original single-player game could be re-introduced, along with the door and multiple levels.
  - GHOST
    - Player comes back as a ghost is among the suggested bonus tasks. I think it would dilute the drama though. Gilding the lily.
- DESIGN
  - Fix how the the character profile picture sometimes changes abruptly when the eyelids are still open.
  - Investigate why the glow on hover over the character names on chosing a role only extends left and up, not right or down. Make it symmetrical.
  - Fix how overlapping explosions aren't organized into a big explosion, but are calculated and emitted as independent explosions, which can result in an arm-piece cutting through where a center piece should be. Look at `detonate(y, x, fireRange)` and `function addFire(y, x, style, origin)` in `server.js`.
  - Customize sprites or design own sprites from scratch.
  - See if we can get scrollbar "thumb" to appear on hover over the roles menu in all browsers, not just Firefox. At the moment, it appears briefly when the menu first appears in Chrome, for example. I think this is preferable to how it was before, though, when all sorts of scrollbars appeared all the time.
  - Make scrollbar "thumb" partially transparent or not overlapping the right edge of the text if possible.
  - Beyond a certain width, chat pane overhangs left edge of input box.
  - Make intro layout more responsive to handle smaller window size, especially the ready button that currently overlaps the title when the screen gets too narrow.
  - Fix scale in CSS to rely only on units relative to screen size and make sure it works on various screen sizes.
  - I replaced the nice, smooth, pixel-by-pixel movement of the single-player version with translate and transition from cell to cell. That was my rough-and-ready solution to keeping the multiple players in sync. With pixel-by-pixel movement, they easily got out of sync as I moved the logic incrementally to the server, I think due to accumulation of small rounding differences in different browsers. The original single-player version from make-your-game looked more like [this version](https://www.retrogames.cc/nes-games/bomberman-usa.html). Pixelwise movement could perhaps be restored by having the server calculate position on an extremely fine-grained grid, with as much resolution as the most detailed screen it's likely to be played on, and let clients round this each to their own current resolution, updated with corrections from the server each tick.
  - Test scrollbars etc. in Edge too. Improve current hacky solution. Understand better.
  - Find a font with more punctiation. None that I've tried looked good enough to sacrifice Wolves and Ravens.
- ROLES
  - Add randomizer to allow alternative profile pictures for roles: name consistently and put each selection in its own folder so we can programmatically pic one from the folder.
  - Get gray's pitchfork in shot.
  - Write backstory or character sketch for each role and think how and where to display them: maybe in windows superimposed partly over the roles with a little box-shadow, and make them visible on hovering over the character image.
- KEYS
  - Let different keys be used for different players, at least for testing, so that two can play on one keyboard.
- REFACTOR
  - Generally, simplify any logic that can be simplified.
  - Consider whether any variable names could be made clearer or standardized.
- STRUCTURE
  - Modularize! Tidy project structure. Split backend and frontend into modules, such as intro and game, and others within those: game setup, socket handlers, key handlers, ...
  - Implement neater "play again" logic, rather then current, crude solution, which is to force a page reload.
  - I originally wrote: "Bring client structure more into line with how things are done on the server: player objects rather than those position and direction arrays (which are a leftover from my initial tinkering with the single-player client-only game to make it multi-player, before I moved the logic to the server)." But before doing that, consider whether it would actually be detrimental to performance. (See Andrew Kelley's talk [Practical Data-Oriented Design](https://www.youtube.com/watch?v=IroPQ150F6c).)
- HOSTING
  - Private.
    - To allow friends to play remotely, as an exercise to learn about hosting, and as an experiment to see how well the networking works. Research how to host on Google App Engine and make accessible by signing in to Google. The latter would need an authentication page before the game starts.
    - An alternative way to play remotely with friends, without adapting to allow multiple game instances, might be to replace the client/server architecture with p2p, and use WebRTC in place of WebSockets.
  - Public.
    - First adapt the server to allow multiple game instances at once. `socket.IO` has a "rooms" feature that would let us group players together into separate games and broadcast specifically to one room. Investigate memory and performance implications of worker threads versus single-thread. Worker threads would simplify the logic. They seem easier to reason about. They don't have access to the network, though, hence no direct web socket access, so the main thread would have to broker messages between game instances and clients. Another alternative would be to have a cluster module, composed of multiple Node processes. There's a `cluster` library that could help. Surely overkill in our case, but just for the sake of curiosity: if the main thread had other computationally intensive tasks, the web socket handling could be offloaded to a reverse proxy, such as Nginx (at the cost of extra network time), or a message broker library, such as Redis or RabbitMQ, that would relay messages to separate threads or processes, even processes on different machines. (Andrei has also mentioned Apache Kafka as a message broker, but Gemini says Redis and RabbitMQ are more lightweight and might be more appropriate to simple use cases.)
    - Glitch has a limited free option to host a Node server. Their free option is public only, though.
